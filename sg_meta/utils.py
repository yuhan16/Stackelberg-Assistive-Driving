"""Implementations of the environment and common utility functions."""
import numpy as np


class Environment:
    """
    This class implements the environment, including car dynamics and reward.
    For dynamics:
    - state: [x, y, v], also encoded by state indices [0, ..., dims].
        - x: horizontal position, [0, ..., 10]
        - y: lane, [0,1,2]
        - v: velocity, [0,1,2] ([stop, slow, fast])
    - action: [nothing, accelerate, decelerate, turn left, turn right, stop], encoded by [0, ..., 5]
    For reward:
    - stage reward is generated by 4 base functions with different given coefficients.
    - leader and different followers have different coefficients.
    - terminal reward is fixed.
    """
    def __init__(self, param) -> None:
        self.seed = param['seed']
        self.rng = np.random.default_rng(self.seed)

        self.obs = param['obstacle_pos']
        self.dst = param['destination_pos']
        self.rf = param['terminal_reward']
        self.dimx, self.dimy, self.dimv = param['dimx'], param['dimy'], param['dimv']
        self.dims = self.dimx * self.dimy * self.dimv
        self.dimua, self.dimub = param['dimua'], param['dimub']
    

    def from_sid_to_s(self, sid):
        """helper function."""
        return [(sid // self.dimv) // self.dimy, (sid // self.dimv) % self.dimy , sid % self.dimv]


    def from_s_to_sid(self, s):
        """helper function."""
        return s[0]*(self.dimy*self.dimv) + s[1]*self.dimv + s[2]


    def is_hit(self, s):
        """Check if car hits obstacles."""
        x, y, v = s[0], s[1], s[2]
        for i in range(len(self.obs)):
            if x == self.obs[i][0] and y == self.obs[i][1]:
                return True
        return False


    def is_outside(self, s):
        """Check if car is outside road."""
        x, y, v = s[0], s[1], s[2]
        if y < 0 or y >= self.dimy or x < 0 or x >= self.dimx:
            return True
        else:
            return False


    def is_destination(self, s):
        """Check if car reach the destination."""
        x, y, v = s[0], s[1], s[2]
        if x == self.dst[0] and y == self.dst[1] and v == 0:
            return True
        else:
            return False


    def is_cross_obs(self, s, s_new):
        """Check if two consective states cross an obstacle. Not allowed."""
        x, y, v = s[0], s[1], s[2]
        x_new, y_new, v_new = s_new[0], s_new[1], s_new[2]
        # check if crossing obstacle in x direction
        if v == 2 or v_new == 2:
            for i in range(len(self.obs)):
                if (y == self.obs[i][1] and y_new == self.obs[i][1]) and (x < self.obs[i][0] and x_new > self.obs[i][0]):
                    return True, i
        # check if crossing obstacle in y direction
        for i in range(len(self.obs)):
            if (x == self.obs[i][0] and x_new == self.obs[i][0]) and (y < self.obs[i][1] and y_new > self.obs[i][1]):
                return True, i        
        return False, None


    def dynamics(self, s, a, b):
        """Car dynamics."""
        x, y, v = s[0], s[1], s[2]

        # special cases (passing crush missing?)
        if self.is_hit(s):
            return [x, y, 0]
        if a == 5 or b == 5:    # stop
            return [x, y, 0]
        
        # process the control
        ax, ay = 0, 0
        if a == 1 or a == 2:    # move forward
            ax = 1 if a == 1 else -1
        elif a == 3 or a == 4:  # change lane
            ay = 1 if a == 3 else -1
        else:
            pass
        bx, by = 0, 0
        if b == 1 or b == 2:    # move forward
            bx = 1 if b == 1 else -1
        elif b == 3 or b == 4:  # change lane
            by = 1 if b == 3 else -1
        else:
            pass
        
        # process lane
        y_new = y + ay + by
        if y_new < 0:
            y_new = 0
        elif y_new > 2:
            y_new = 2
        else:
            pass
        
        # process v
        v_new = v + ax + bx
        if v_new < 0:
            v_new = 0
        elif v_new > 2:
            v_new = 2
        else:
            pass
        x_new = x + v_new
        if x_new >= self.dimx:
            x_new = self.dimx - 1
        flag, obs_id = self.is_cross_obs(s, [x_new, y_new, v_new])
        if flag:
            return [self.obs[obs_id][0], self.obs[obs_id][1], 0]
        
        return [x_new, y_new, v_new]


    def transition_matrix(self):
        """
        This function generates the equivalent deterministic transition probability matrix: p(s'|s,a,b).
        The state is encoded by state indices [0, ..., dims].
        Given (s_t, a_t, b_t), p[:, s_t, a_t, b_t] only has one positive value, which corresponds to the next state.
        """
        p = np.zeros((self.dims, self.dims, self.dimua, self.dimub))
        for i in range(self.dims):
            for j in range(self.dimua):
                for k in range(self.dimub):
                    sid = self.from_s_to_sid( self.dynamics(self.from_sid_to_s(i), j, k) )
                    p[sid, i,j,k] = 1
        return p


    def dynamics_raw(self, s, a, b):
        """
        Car dynamics that does not contain safety constraints, used to generate stage reward. 
        NOT the same as dynamics().
        """
        x, y, v = s[0], s[1], s[2]
        if a == 5 or b == 5:    # stop
            return [x, y, 0]
        ax, ay = 0, 0
        if a == 1 or a == 2:    # move forward
            ax = 1 if a == 1 else -1
        elif a == 3 or a == 4:  # change lane
            ay = 1 if a == 3 else -1
        else:
            pass
        bx, by = 0, 0
        if b == 1 or b == 2:    # move forward
            bx = 1 if b == 1 else -1
        elif b == 3 or b == 4:  # change lane
            by = 1 if b == 3 else -1
        else:
            pass
        y_new = y + ay + by
        v_new = v + ax + bx
        if v_new < 0:
            v_new = 0
        elif v_new > 2:
            v_new = 2
        else:
            pass
        x_new = x + v_new
        flag, obs_id = self.is_cross_obs(s, [x_new, y_new, v_new])
        if flag:
            return [self.obs[obs_id][0], self.obs[obs_id][1], 0]
        
        return [x_new, y_new, v_new]


    def stage_reward(self, c1, c2, c3, c4):
        """
        This function generates the stage cost matrix for leader/follower based on potential fields generated by 4 base functions.
        - f1: slop cost, affine: z = c1[0]*x + c1[1]. reaching to desination has small cost
        - f2: obstacle cost, log barrier: z = log(|[x-obs; y-yobs]|_{c2[0:2]}) / c2[2]. center cost is constant: z = c3.
        - f3: lane edge violation cost, constant: z = c3.
        - f4: lane change cost, constant: z = c4. 0 for nothing and stop action.
        Negative cost is the reward.
        """
        g = self.rng.random((self.dims, self.dimua, self.dimub))    # random values to avoid flat regions in learning

        # 4 base cost function
        f3 = lambda x, y: c3 if self.is_outside([x,y,0]) else 0      # lane violation or driving outside (x direction) cost
        f4 = lambda x, y: c4                                # lane changing cost
        def f1(x, y):   # path cost
            if x < self.dimx and y >=0 and y < self.dimy:
                return c1[0] * abs(x-self.dst[0]) + c1[1] * abs(y-self.dst[1])
            else:
                return 0
        def f2(x, y):   # obstacle cost
            f = 0
            for i in range(len(self.obs)):
                v = np.array([x-self.obs[i][0], y-self.obs[i][1]])
                tmp = v @ np.diag(c2[:-1]) @ v
                if tmp >= 1:
                    f += 0      # no cost
                elif tmp == 0:
                    f += c3     # center cost
                else:
                    f += c2[-1] * ( -np.log(tmp) )      # log barrier cost, barrier is -log()
            return f
        
        # predict for every s, a, b and obtain the cost. Special s such as s = obs, s = goal, set alternatively.
        for i in range(self.dims):
            if self.is_hit(self.from_sid_to_s(i)):
                g[i, :] = c3
                g[i, 5,5] = 0       # when hit, should stop, no cost.
                continue

            for j in range(self.dimua):
                for k in range(self.dimub):
                    s_new = self.dynamics_raw(self.from_sid_to_s(i), j, k)      # use raw dynamics
                    #print(s_new)
                    x_new, y_new, v_new = s_new[0], s_new[1], s_new[2]
                    if (j >= 3 and j <= 4) or (k >= 3 and k <= 4):
                        g[i,j,k] = f1(x_new, y_new) + f2(x_new, y_new) + f3(x_new, y_new) + f4(x_new, y_new)   # lane changing cost
                    else:
                        g[i,j,k] = f1(x_new, y_new) + f2(x_new, y_new) + f3(x_new, y_new)
                    # v is max but accelerate, v is 0 but decelerate
                    v = self.from_sid_to_s(i)[2]
                    if ( v == 2 and (j == 1 or k == 1) ) or ( v == 0 and (j==2 or k == 2) ):
                        g[i,j,k] += 1
                    # stop brings an additional cost
                    if j == 5 or k == 5:
                        g[i,j,k] += 1
        return -g   # ADD NEGATIVE SIGN!


    def terminal_reward(self):
        """Terminal reward, a vector in dims. only positive reward if reaching the destination (with arbitrary velocity)."""
        g_f = np.zeros(self.dims)
        g_f[self.from_s_to_sid(self.dst + [0])] = self.rf
        g_f[self.from_s_to_sid(self.dst + [1])] = 0
        g_f[self.from_s_to_sid(self.dst + [2])] = 0
        return g_f


class Utilities:
    """Miscellaneous helper functions."""
    def __init__(self) -> None:
        pass

    def load_data(self):
        """load learning data. data grouped by list according to types."""
        data = []
        import os
        if not os.path.exists('data'):
            raise Exception('No data directory. Run generate_data() first.')
        else:
            for theta in range(5):
                fname = f'data/f{theta}_data.npy'
                if not os.path.exists(fname):
                    raise Exception(f'No data found for type {theta} follower. Run generate_data() first.')
                else:
                    data.append( np.load(fname) )
        return data
    
    
    def load_adapted_utility(self, theta):
        """load type theta follower's adapted utility."""
        import os
        fname = f'data/gb_adapt_{theta}.npy'
        if not os.path.exists(fname):
            raise Exception('No adapted model found. Run meta-learning and adaptation first. See meta_learn.py')
        else:
            g_adapt = np.load(fname)
        return g_adapt


    def print_key_parameters(self, param):
        print('Parameters:')
        print(f'--random seed: {param["seed"]}')

        print(f'--destination: {param["destination_pos"]}')
        print(f'--obstacles: {param["obstacle_pos"]}')

        print(f'--total types: {param["total_type"]}')
        print(f'--type_pdf: {param["type_pdf"]}')

        print(f'--alp in maml: {param["alp"]}')
        print(f'--beta in maml: {param["beta"]}')
        
        print(f'--discretization time: {param["dt"]}\n')
